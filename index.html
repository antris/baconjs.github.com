<!DOCTYPE html>
<html>
<head>
  <title>Bacon.js - A small functional reactive programming library for JavaScript</title>
  <link type="text/css" rel="stylesheet" href="style.css" />
</head>
<body>
<div id="main">
  <h1>Bacon.js <small>A small (~5kb) functional reactive programming library for JavaScript</small></h1>
  <p>Have you ever visited the callback hell while handling events in JavaScript?</p>
  <p>Bacon.js transforms your event spaghetti into clean and declarative feng shui bacon, by switching from imperative to functional. It's like replacing nested for-loops with functional programming concepts like <code>map</code> and <code>filter</code>.</p>

  <p>Stop working on individual events and work with <strong>event streams</strong> instead. Transform the stream data with <code>map</code> and <code>filter</code>. Join streams with <code>merge</code> and <code>combine</code>. Then switch to the heavier weapons and wield <code>flatMap</code> and <code>combineTemplate</code> like a boss.</p>

  <ul>
    <li><a href="https://github.com/raimohanska/bacon.js">The project on GitHub</a></li>
    <li><a href="https://github.com/raimohanska/bacon.js/blob/master/lib/Bacon.js">Generated JavaScript</a> (see below for building the JavaScript yourself)</li>
    <li><a href="https://github.com/raimohanska/bacon.js/blob/master/lib/Bacon.min.js">Generated JavaScript (minified, no asserts)</a></li>
    <li><a href="https://github.com/raimohanska/bacon.js/blob/master/spec/BaconSpec.coffee">Specs</a></li>
    <li><a href="https://github.com/raimohanska/bacon.js/blob/master/examples/examples.html">Examples</a></li>
    <li><a href="https://github.com/raimohanska/bacon.js/wiki">Diagrams</a> for the visual learners</li>
    <li><a href="http://nullzzz.blogspot.com">My Blog</a> with some baconful and reactive postings along with a Bacon.js tutorial</li>
  </ul>

  <p>You can also check out my entertaining (LOL), interactive, solid-ass <a href="http://raimohanska.github.com/bacon.js-slides/">slideshow</a>.</p>

  <p>And remember to give me feedback on the bacon! Let me know if you've
  used it. Tell me how it worked for you. What's missing? What's wrong?
  Please contribute!</p>

  <p>Bacon.js is created by Juha Paananen and is MIT Licensed.</p>

  <div id="table-of-contents">
    <h2>Table of Contents</h2>
    <ol>
      <li><a href="#installation">Installation</a></li>
      <li><a href="#introduction">Introduction</a></li>
      <li>
        <a href="#api">API</a>
        <ol>
          <li><a href="#creating-streams">Creating Streams</a></li>
          <li><a href="#common-methods-in-eventstreams-and-properties">Common methods in EventStreams and Properties</a></li>
          <li><a href="#eventstream">EventStream</a></li>
          <li><a href="#property">Property</a></li>
          <li><a href="#combining-eventstreams-and-properties">Combining EventStreams and Properties</a></li>
          <li><a href="#function-construction-rules">Function construction rules</a></li>
          <li><a href="#latest-value-of-a-property-or-an-eventstream">Latest value of a Property or an EventStream</a></li>
          <li><a href="#bus">Bus</a></li>
          <li><a href="#event">Event</a></li>
          <li><a href="#errors">Errors</a></li>
          <li><a href="#cleaning-up">Cleaning up</a></li>
          <li><a href="#eventstream-and-property-semantics">EventStream and Property semantics</a></li>
          <li><a href="#for-rxjs-users">For RxJs users</a></li>
        </ol>
      </li>
      <li><a href="#examples">Examples</a></li>
      <li><a href="#build">Build</a></li>
      <li><a href="#test">Test</a></li>
      <li><a href="#dependencies">Dependencies</a></li>
      <li><a href="#compatibility-with-other-libraries">Compatibility with other libraries</a></li>
      <li><a href="#compatibility-with-browsers">Compatibility with browsers</a></li>
      <li><a href="#node-js">Node.js</a></li>
      <li><a href="#why-use-bacon">Why use Bacon?</a></li>
      <li><a href="#contribute">Contribute</a></li>
    </ol>
  </div>

  <h2><a name="installation">Installation</a></h2>

  <p>You can download the latest <a href="https://raw.github.com/raimohanska/bacon.js/master/lib/Bacon.js">generated javascript</a>.</p>

  <p>..or you can use script tags to include this file directly from Github:</p>

  <pre><code>&lt;script src="https://raw.github.com/raimohanska/bacon.js/master/lib/Bacon.js"&gt;&lt;/script&gt;</code></pre>

  <p>If you're targeting to <a href="http://nodejs.org/">node.js</a>, you can</p>

  <pre><code>npm install baconjs</code></pre>

  <p>For <a href="https://github.com/twitter/bower">bower</a> users:</p>

  <pre><code>bower install bacon</code></pre>

  <h2><a name="introduction">Introduction</a></h2>

  <p>The idea of Functional Reactive Programming is quite well described by Conal Elliot at <a href="http://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming/1030631#1030631">Stack Overflow</a>.</p>

  <p>Bacon.js is a library for functional reactive programming. Or let's say it's a library for
  working with events and dynamic values (which are called Properties in Bacon.js). </p>

  <p>Anyways, you can wrap an event source, 
  say "mouse clicks on an element" into an <code>EventStream</code> by saying</p>

  <pre><code>var cliks = $("h2").asEventStream("click")</code></pre>

  <p>Each EventStream represents a stream of events. It is an Observable object, meaning
  that you can listen to events in the stream using, for instance, the <code>onValue</code> method 
  with a callback. Like this:</p>

  <pre><code>cliks.onValue(function() { alert("you clicked the h2 element") })</code></pre>

  <p>But you can do neater stuff too. The Bacon of bacon.js is in that you can transform, 
  filter and combine these streams in a multitude of ways (see API below). The methods <code>map</code>,
  <code>filter</code>, for example, are similar to same functions in functional list programming
  (like <a href="http://documentcloud.github.com/underscore/">Underscore</a>). So, if you say</p>

  <pre><code>function always(value) { return function() { return value } }

var plus = $("#plus").asEventStream("click").map(always(1))
var minus = $("#minus").asEventStream("click").map(always(-1))
var both = plus.merge(minus)</code></pre>

  <p>.. you'll have a stream that will output the number 1 when the "plus" button is clicked
  and another stream outputting -1 when the "minus" button is clicked. The <code>both</code> stream will
  be a merged stream containing events from both the plus and minus streams. This allows
  you to subscribe to both streams with one handler:</p>

  <pre><code>both.onValue(function(val) { /* val will be 1 or -1 */ })</code></pre>

  <p>In addition to EventStreams, bacon.js has a thing called <code>Property</code>, that is almost like an
  EventStream, but has a "current value". So things that change and have a current state are 
  Properties, while things that consist of discrete events are EventStreams. You could think
  mouse clicks as an EventStream and mouse position as a Property. You can create Properties from
  an EventStream with <code>scan</code> or <code>toProperty</code> methods. So, let's say</p>

  <pre><code>function add(x, y) { return x + y }
var counter = both.scan(0, add)
counter.onValue(function(sum) { $("#sum").text(sum) })</code></pre>

  <p>The <code>counter</code> property will contain the sum of the values in the <code>both</code> stream, so it's practically 
  a counter that can be increased and decreased using the plus and minus buttons. The <code>scan</code> method 
  was used here to calculate the "current sum" of events in the <code>both</code> stream, by giving a "seed value"
  <code>0</code> and an "accumulator function" <code>add</code>. The scan method creates a property that starts with the given
  seed value and on each event in the source stream applies the accumulator function to the current
  property value and the new value from the stream.</p>

  <p>Properties can be very conventiently used for assigning values and attributes to DOM elements with JQuery.
  Here we assign the value of a property as the text of a span element whenever it changes:</p>

  <pre><code>property.assign($("span"), "text")</code></pre>

  <p>Hiding and showing the same span depending on the content of the property value is equally straightforward</p>

  <pre><code>function hiddenForEmptyValue(value) { return value == "" ? "hidden" : "visible" }
property.map(hiddenForEmptyValue).assign($("span"), "css", "visibility")</code></pre>

  <p>In the example above a property value of "hello" would be mapped to "visible", which in turn would result in Bacon calling</p>

  <pre><code>$("span).css("visibility", "visible")</code></pre>

  <h2><a name="api">API</a></h2>

  <h3><a name="creating-streams">Creating streams</a></h3>

  <p><code>$.asEventStream("click")</code> creates an EventStream from events on a
  jQuery or Zepto.js object. You can pass optional arguments to add a 
  jQuery live selector and/or a function that processes the jQuery 
  event and its parameters, if given, like this:
    <code>$("#my-div").asEventStream("click", ".more-specific-selector")</code>
    <code>$("#my-div").asEventStream("click", ".more-specific-selector", function(event, args) { return args[0] })</code>
    <code>$("#my-div").asEventStream("click", function(event, args) { return args[0] })</code></p>

  <p><code>Bacon.fromPromise(promise)</code> creates an EventStream from a Promise object such as JQuery Ajax. This stream will contain a single value or an error, followed immediately by stream end.</p>

  <p><code>Bacon.interval(interval, value)</code> repeats the single element
  indefinitely with the given interval (in milliseconds)</p>

  <p><code>Bacon.sequentially(interval, values)</code> creates a stream containing given
  values (given as array). Delivered with given interval (in milliseconds)</p>

  <p><code>Bacon.repeatedly(interval, values)</code> repeats given elements indefinitely
  with given interval (in milliseconds)</p>

  <p><code>Bacon.fromEventTarget(target, event)</code> creates an EventStream from events
  on a DOM EventTarget or Node.JS EventEmitter object.</p>

  <p><code>Bacon.fromPoll(interval, f)</code> polls given function with given interval.
  Function should return Events: either Next or End.</p>

  <p><code>Bacon.later(delay, value)</code> creates a single-element stream that
  produces given value after given delay (milliseconds).</p>

  <p><code>new Bacon.EventStream(subscribe)</code> creates an event stream with the given 
  subscribe function.</p>

  <p><code>property.changes()</code> creates a stream of changes to the Property (see Property API below)</p>

  <p><code>new Bacon.Bus()</code> creates a pushable/pluggable stream (see Bus section
  below)</p>

  <h3><a name="common-methods-in-eventstreams-and-properties">Common methods in EventStreams and Properties</a></h3>

  <p><code>streamOrProperty.map(f)</code> maps values using given function, returning a new
  EventStream. Instead of a function, you can also provide a constant
  value. Further, you can use a property extractor string like
  ".keyCode". So, if f is a string starting with a
  dot, the elements will be mapped to the corresponding field/function in the event
  value. For instance map(".keyCode") will pluck the keyCode field from
  the input values. If keyCode was a function, the result stream would
  contain the values returned by the function. The Function Construction
  rules below apply here.</p>

  <p><code>stream.map(property)</code> maps the stream events to the current value of
  the given property. This is equivalent to <code>property.sampledBy(stream)</code>.</p>

  <p><code>streamOrProperty.mapError(f)</code> maps errors using given function. More
  spedifically, feeds the "error" field of the error event to the function
  and produces a "Next" event based on the return value. Function
  Construction rules apply.</p>

  <p><code>streamOrProperty.mapEnd(f)</code> Adds an extra Next event just before End. The value is created
  by calling the given function when the source stream ends. Instead of a
  function, a static value can be used. You can even omit the argument if</p>

  <p><code>streamOrProperty.filter(f)</code> filters values using given predicate function. 
  Instead of a function, you can use a constant value (true/false) or a
  property extractor string (like ".isValuable") instead. Just like with
  <code>map</code>, indeed.</p>

  <p><code>stream.filter(property)</code> filters a stream based on the value of a
  property. Event will be included in output iff the property holds <code>true</code>
  at the time of the event.</p>

  <p><code>streamOrProperty.takeWhile(f)</code> takes while given predicate function holds true</p>

  <p><code>streamOrProperty.take(n)</code> takes at most n elements from the stream</p>

  <p><code>streamOrProperty.takeUntil(stream2)</code> takes elements from source until a Next event 
  appears in the other stream. If other stream ends without value, it is
  ignored</p>

  <p><code>streamOrProperty.skip(n)</code> skips the first n elements from the stream</p>

  <p><code>streamOrProperty.delay(delay)</code> delays the stream/property by given amount of milliseconds. Does not delay the initial value of a Property.</p>

  <p><code>streamOrProperty.throttle(delay)</code> throttles stream/property by given amount of milliseconds. This means that event is only emitted after the given
  "quiet period". Does not affect the initial value of a Property.</p>

  <p><code>streamOrProperty.doAction(f)</code> returns a stream/property where the function f
  is executed for each value, before dispatching to subscribers. This is
  useful for debugging, but also for stuff like calling the
  preventDefault() method for events. In fact, you can
  also use a property-extractor string instead of a function, as in
  ".preventDefault". The old name for
  this method is <code>do</code> which is temporarily supported for backward
  compatibility.</p>

  <p><code>streamOrProperty.not()</code> returns a stream/property that inverts boolean
  values</p>

  <p><code>streamOrProperty.flatMap(f)</code> for each element in the source stream, spawn a new
  stream using the function <code>f</code>. Collect events from each of the spawned
  streams into the result stream. This is very similar to selectMany in
  RxJs.</p>

  <p>stream.flatMap() can be used conveniently with <code>Bacon.once()</code> and <code>Bacon.never()</code> for converting and filtering at the same time, including only some of the results.</p>

  <p>Example - converting strings to integers, skipping empty values:</p>

  <pre><code>stream.flatMap(function(text) {
    return (text != "") ? Bacon.once(parseInt(text)) : Bacon.never()
})</code></pre>

  <p><code>streamOrProperty.flatMapLatest(f)</code> like flatMap, but instead of including events from
  all spawned streams, only includes them from the latest spawned stream.
  You can think this as switching from stream to stream. The old name for
  this method is <code>switch</code> which is temporarily supported for backward
  compatibility.</p>

  <h3><a name="eventstream">EventStream</a></h3>

  <p><code>Bacon.EventStream</code> a stream of events. See methods below.</p>

  <p><code>stream.onValue(f)</code> subscribes a given handler function to event
  stream. Function will be called for each new value in the stream. This
  is the simplest way to assign a side-effect to a stream. The difference
  to the <code>subscribe</code> method is that the actual stream values are
  received, instead of Event objects. Function Construction rules below
  apply here.</p>

  <p><code>stream.onValues(f)</code> like onValue, but splits the value (assuming its an
  array) as function arguments to <code>f</code></p>

  <p><code>stream.onEnd(f)</code> subscribes a callback to stream end. The function will
  be called when the stream ends.</p>

  <p><code>stream.subscribe(f)</code> subscribes given handler function to
  event stream. Function will receive Event objects (see below).
  The subscribe() call returns a <code>unsubscribe</code> function that you can
  call to unsubscribe. You can also unsubscribe by returning
  <code>Bacon.noMore</code> from the handler function as a reply to an Event.</p>

  <p><code>stream.scan(seed, f)</code> scans stream with given seed value and
  accumulator function, resulting to a Property. For example, you might
  use zero as seed and a "plus" function as the accumulator to create
  an "integral" property. Instead of a function, you can also supply a
  method name such as ".concat", in which case this method is called on
  the accumulator value and the new stream value is used as argument.</p>

  <p>Example:</p>

  <pre><code>var plus = function (a,b) { return a + b }
Bacon.sequentially(1, [1,2,3]).scan(0, plus)</code></pre>

  <p>This would result to following elements in the result stream:</p>

  <pre><code>seed value = 0
0 + 1 = 1
1 + 2 = 3
3 + 3 = 6</code></pre>

  <p><code>stream.skipDuplicates([isEqual])</code> drops consecutive equal elements. So,
  from [1, 2, 2, 1] you'd get [1, 2, 1]. Uses the === operator for equality
  checking by default. If the isEqual argument is supplied, checks by calling
  isEqual(oldValue, newValue)</p>

  <p><code>stream.merge(stream2)</code> merges two streams into one stream that delivers
  events from both</p>

  <p><code>stream.bufferWithTime(delay)</code> buffers stream events with given delay.
  The buffer is flushed at most once in the given delay. So, if your input
  contains [1,2,3,4,5,6,7], then you might get two events containing [1,2,3,4]
  and [5,6,7] respectively, given that the flush occurs between numbers 4 and 5.</p>

  <p><code>stream.bufferWithCount(count)</code> buffers stream events with given count.
  The buffer is flushed when it contains the given number of elements. So, if
  you buffer a stream of [1, 2, 3, 4, 5] with count 2, you'll get output
  events with values [1, 2], [3, 4] and [5].</p>

  <p><code>stream.toProperty()</code> creates a Property based on the
  EventStream. Without arguments, you'll get a Property without an initial value.
  The Property will get its first actual value from the stream, and after that it'll
  always have a current value.</p>

  <p><code>stream.toProperty(initialValue)</code> creates a Property based on the
  EventStream with the given initial value that will be used as the current value until
  the first value comes from the stream.</p>

  <p><code>stream.decorateWith(name, property)</code> decorates stream values (must be
  objects) with a new property with the given name and a value taken from
  the given Property.</p>

  <h3><a name="property">Property</a></h3>

  <p><code>Bacon.Property</code> a reactive property. Has the concept of "current value".
  You can create a Property from an EventStream by using either toProperty 
  or scan method. Note depending on how a Property is created, it may or may not
  have an initial value.</p>

  <p><code>Bacon.constant(x)</code> creates a constant property with value x.</p>

  <p><code>property.subscribe(f)</code> subscribes a handler function to property. If there's
  a current value, an <code>Initial</code> event will be pushed immediately. <code>Next</code> 
  event will be pushed on updates and an <code>End</code> event in case the source 
  EventStream ends.</p>

  <p><code>property.onValue(f)</code> similar to eventStream.onValue, except that also
  pushes the initial value of the property, in case there is one. 
  See Function Construction rules below for different forms of calling this method.</p>

  <p><code>property.onValues(f)</code> like onValue, but splits the value (assuming its an
  array) as function arguments to <code>f</code></p>

  <p><code>property.onEnd(f)</code> subscribes a callback to stream end. The function will
  be called when the source stream of the property ends.</p>

  <p><code>property.assign(obj, method, [param...])</code> calls the method of the given
  object with each value of this Property. You can optionally supply
  arguments which will be used as the first arguments of the method call.
  For instance, if you want to assign your Property to the "disabled"
  attribute of a JQuery object, you can do this:</p>

  <pre><code>myProperty.assign($("#my-button"), "attr", "disabled")</code></pre>

  <p>A simpler example would be to toggle the visibility of an element based
  on a Property:</p>

  <pre><code>myProperty.assign($("#my-button"), "toggle")</code></pre>

  <p>Note that the <code>assign</code> method is actually just a synonym for <code>onValue</code> and
  the function construction rules below apply to both.</p>

  <p><code>property.combine(property2, f)</code> combines the latest values of the two
  properties using a two-arg function. Similarly to <code>scan</code>, you can use a
  method name instead, so you could do <code>a.combine(b, ".concat")</code> for two
  properties with array value.</p>

  <p><code>property.sample(interval)</code> creates an EventStream by sampling the
  property value at given interval (in milliseconds)</p>

  <p><code>property.sampledBy(stream)</code> creates an EventStream by sampling the
  property value at each event from the given stream. The result
  EventStream will contain the property value at each event in the source
  stream.</p>

  <p><code>property.sampledBy(stream, f)</code> samples the property on stream events.
  The result EventStream values will be formed using the given function
  <code>f(propertyValue, streamValue)</code>. You can use a method name (such as
  ".concat") instead of a function too.</p>

  <p><code>property.skipDuplicates([isEqual])</code> drops consecutive equal elements. So,
  from [1, 2, 2, 1] you'd get [1, 2, 1]. Uses the === operator for equality
  checking by default. If the isEqual argument is supplied, checks by calling
  isEqual(oldValue, newValue)</p>

  <p><code>property.changes()</code> returns an EventStream of property value changes.
  Returns exactly the same events as the property itself, except any Initial
  events. Note that property.changes() does NOT skip duplicate values, use .skipDuplicates() for that.</p>

  <p><code>property.and(other)</code> combines properties with the <code>&amp;&amp;</code> operator.</p>

  <p><code>property.or(other)</code> combines properties with the <code>||</code> operator.</p>

  <p><code>property.decode(mapping)</code> decodes input using the given mapping. Is a
  bit like a switch-case or the decode function in Oracle SQL. For
  example, the following would map the value 1 into the the string "mike" 
  and the value 2 into the value of the <code>who</code> property.</p>

  <pre><code>property.decode({1 : "mike", 2 : who})</code></pre>

  <p>This is actually based on <code>combineTemplate</code> so you can compose static
  and dynamic data quite freely, as in</p>

  <pre><code>property.decode({1 : { type: "mike" }, 2 : { type: "other", whoThen : who }})</code></pre>

  <h3><a name="combining-eventstreams-and-properties">Combining EventStreams and Properties</a></h3>

  <p><code>Bacon.combineAsArray(streams)</code> combines Properties and EventStreams so 
  that the result Property will have an array of all property values as its value.
  The input array may contain both Properties and EventStreams. In the
  latter case, the stream is first converted into a Property and then
  combined with the other properties.</p>

  <p>`Bacon.combineAsArray(s1, s2, ...) just like above, but with streams
  provided as a list of arguments as opposed to a single array.</p>

  <p><code>Bacon.mergeAll(streams)</code> merges given array of EventStreams.</p>

  <p><code>Bacon.combineAll(streams, f)</code> combines given list of streams/properties
  using the given combinator function <code>f(s1, s2)</code>. The function is applied in a
  fold-like fashion: the first two streams are given to the function
  first. Then the result of this operation is combined with the third
  stream and so on. In this variant, the combinator function is applied to
  the streams themselves, not the stream values.</p>

  <p><code>Bacon.combineWith(streams, f)</code> combines given list of streams/properties
  using the given combinator function <code>f(v1, v2)</code>. In this variant, the
  combinator function is used for combining two stream values, not the
  streams themselves. This is equivalent to combining the
  streams/properties using the combine method like a.combine(b,
  f).combine(c.f) etc. For example, you can combine properties containing
  arrays into a single array property, with Bacon.combineWith(properties,
  ".concat").</p>

  <p><code>Bacon.combineTemplate(template)</code> combines streams using a template
  object. For instance, assuming you've got streams or properties named
  <code>password</code>, <code>username</code>, <code>firstname</code> and <code>lastname</code>, you can do</p>

  <pre><code>var loginInfo = Bacon.combineTemplate({
    userid: username, 
    passwd: password, 
    name: { first: firstname, last: lastname }})</code></pre>

  <p>.. and your new loginInfo property will combine values from all these
  streams using that template, whenever any of the streams/properties 
  get a new value. For instance, it could yield a value such as</p>

  <pre><code>{ userid: "juha", 
  passwd: "easy", 
  name : { first: "juha", last: "paananen" }}</code></pre>

  <p>In addition to combining data from streams, you can include constant
  values in your templates.</p>

  <p>Note that all Bacon.combine* methods produce a Property instead of an EventStream. If you need the result as an EventStream you might want to use property.changes()</p>

  <pre><code>Bacon.combineWith([stream1,stream2], function(v1,v2) {} ).changes()</code></pre>

  <h3><a name="function-construction-rules">Function construction rules</a></h3>

  <p>Many methods in Bacon have a single function as their argument. Many of these
  actually accept a wider range of different arguments that they use for
  constructing the function.</p>

  <p>Here are the different forms you can use, with examples. The basic form
  would be</p>

  <p><code>stream.map(f)</code> maps values using the function f(x)</p>

  <p>As an extension to the basic form, you can use partial application:</p>

  <p><code>stream.map(f, "bacon")</code> maps values using the function f(x, y), using
  "bacon" as the first argument, and stream value as the second argument.</p>

  <p><code>stream.map(f, "pow", "smack")</code> maps values using the function f(x, y,
  z), using "pow" and "smack" as the first two arguments and stream value
  as the third argument.</p>

  <p>Then, you can create method calls like this:</p>

  <p><code>stream.onValue(object, method)</code> calls the method having the given name,
  with stream value as the argument.</p>

  <p><code>titleText.onValue($("#title"), "text")</code> which would call the "text" method of the jQuery object matching to the HTML element with the id "title"</p>

  <p><code>disableButton.onValue($("#send"), "attr", "disabled")</code> which would call
  the attr method of the #send element, with "disabled" as the first
  argument. So if your property has the value <code>true</code>, it would call
  $("#send").attr("disabled", true)</p>

  <p>You can call methods or return field values using a "property extractor"
  syntax. With this syntax, Bacon checks the type of the field and if it's indeed a method, it calls it. Otherwise it just returns field value. For example:</p>

  <p><code>stream.map(".length")</code> would return the value of the "length" field of
  stream values. Would make sense for a stream of arrays. So, you'd get 2
  for <code>["cat", "dog"]</code></p>

  <p><code>stream.map(".stuffs.length")</code> would pick the length of the "stuffs"
  array that is a field in the stream value. For example, you'd get 2 for
  <code>{ stuffs : ["thing", "object"] }</code></p>

  <p><code>stream.map(".dudes.1") would pick the second object from the nested
  "dudes" array. For example, you'd get "jack" for</code>{ dudes : ["john",
  "jack"] }`.</p>

  <p><code>stream.doAction(".preventDefault")</code> would call the "preventDefault" method of
  stream values. The old name for
  this method is <code>do</code> which is temporarily supported for backward
  compatibility.</p>

  <p><code>stream.filter(".attr", "disabled").not()</code> would call <code>.attr("disabled")</code> on
  stream values and filter by the return value. This would practically
  inlude only disabled jQuery elements to the result stream.</p>

  <p>If none of the above applies, Bacon will return a constant value. For
  instance:</p>

  <p><code>mouseClicks.map({ isMouseClick: true })</code> would map all events to the
  object <code>{ isMouseClick: true }</code></p>

  <p>Methods that support function construction include 
  at least <code>onValue</code>, <code>onError</code>, <code>onEnd</code>, <code>map</code>, <code>filter</code>, <code>assign</code>, <code>takeWhile</code>, <code>mapError</code> and <code>do</code>.</p>

  <h3><a name="latest-value-of-a-property-or-an-eventstream">Latest value of a Property or an EventStream</a></h3>

  <p><code>Bacon.latestValue(stream)</code> will return a function that will return the
  latest value from the given stream or property. Notice that the
  side-effect of this is that there will be an irremovable subscriber for
  the stream that takes care of storing the latest value.</p>

  <p>This is not really recommended. Usually you'll do better by using
  combinators such as <code>combine</code>, <code>sampledBy</code> and <code>combineTemplate</code>.</p>

  <h3><a name="bus">Bus</a></h3>

  <p>Bus is an EventStream that allows you to <code>push</code> values into the stream.
  It also allows pluggin other streams into the Bus. The Bus practically
  merges all plugged-in streams and the values pushed using the <code>push</code>
  method.</p>

  <p><code>new Bacon.Bus()</code> returns a new Bus.</p>

  <p><code>bus.push(x)</code> pushes the given value to the stream.</p>

  <p><code>bus.end()</code> ends the stream. Sends an End event to all subscribers.
  After this call, there'll be no more events to the subscribers. 
  Also, the Bus <code>push</code> and <code>plug</code> methods have no effect.</p>

  <p><code>bus.error(e)</code> sends an Error with given message to all subscribers</p>

  <p><code>bus.plug(stream)</code> plugs the given stream to the Bus. All events from
  the given stream will be delivered to the subscribers of the Bus.</p>

  <p>The plug method practically allows you to merge in other streams after
  the creation of the Bus. I've found Bus quite useful as an event broadcast
  mechanism in the
  <a href="https://github.com/raimohanska/worzone">Worzone</a> game, for instance.</p>

  <h3><a name="event">Event</a></h3>

  <p><code>Bacon.Event</code> has subclasses <code>Next</code>, <code>End</code>, <code>Error</code> and <code>Initial</code></p>

  <p><code>Bacon.Next</code> next value in an EventStream or a Property. Call isNext() to
  distinguish a Next event from other events.</p>

  <p><code>Bacon.End</code> an end-of-stream event of EventStream or Property. Call isEnd() to
  distinguish an End from other events.</p>

  <p><code>Bacon.Error</code> an error event. Call isError() to distinguish these events
  in your subscriber, or use <code>onError</code> to react to error events only.
  <code>errorEvent.error</code> returns the associated error object (usually string).</p>

  <p><code>Bacon.Initial</code> the initial (current) value of a Property. Call isInitial() to
  distinguish from other events. Only sent immediately after subscription
  to a Property.</p>

  <p>Event properties and methods:</p>

  <p><code>event.value</code> the value associated with a Next or Initial event</p>

  <p><code>event.hasValue()</code> returns true for events of type Initial and Next</p>

  <p><code>event.isNext()</code> true for Next events</p>

  <p><code>event.isInitial()</code> true for Initial events</p>

  <p><code>event.isEnd()</code> true for End events</p>

  <h3><a name="errors">Errors</a></h3>

  <p><code>Error</code> events are always passed through all stream combinators. So, even
  if you filter all values out, the error events will pass though. If you
  use flatMap, the result stream will contain Error events from the source
  as well as all the spawned stream.</p>

  <p>You can take action on errors by using the <code>streamOrProperty.onError(f)</code>
  callback.</p>

  <p><code>streamOrProperty.errors()</code> returns a stream containing Error events only.
  Same as filtering with a function that always returns false.</p>

  <p>See also the <code>mapError()</code> function above.</p>

  <p>An Error does not terminate the stream. The method <code>streamOrProperty.endOnError()</code>
  returns a stream/property that ends immediately after first error.</p>

  <p>Bacon.js doesn't currently generate any Error events itself (except when
  converting errors using Bacon.fromPromise). Error
  events definitely would be generated by streams derived from IO sources
  such as AJAX calls.</p>

  <h3><a name="cleaning-up">Cleaning up</a></h3>

  <p>As described above, a subscriber can signal the loss of interest in new events 
  in any of these two ways:</p>

  <ol>
  <li>Return <code>Bacon.noMore</code> from the handler function</li>
  <li>Call the <code>dispose()</code> function that was returned by the <code>subscribe()</code>
  call.</li>
  </ol>

  <p>Based on my experience on RxJs coding, an actual side-effect subscriber
  in application-code never does this. So the business of unsubscribing is
  mostly internal business and you can ignore it unless you're working on
  a custom stream implementation or a stream combinator. In that case, I
  welcome you to contribute your stuff to bacon.js.</p>

  <h3><a name="eventstream-and-property-semantics">EventStream and Property semantics</a></h3>

  <p>The state of an EventStream can be defined as (t, os) where <code>t</code> is time
  and <code>os</code> the list of current subscribers. This state should define the
  behavior of the stream in the sense that</p>

  <ol>
  <li>When a Next event is emitted, the same event is emitted to all subscribers</li>
  <li>After an event has been emitted, it will never be emitted again, even
  if a new subscriber is registered. A new event with the same value may
  of course be emitted later.</li>
  <li>When a new subscriber is registered, it will get exactly the same
  events as the other subscriber, after registration. This means that the
  stream cannot emit any "initial" events to the new subscriber, unless it
  emits them to all of its subscribers.</li>
  <li>A stream must never emit any other events after End (not even another End)</li>
  </ol>

  <p>The rules are deliberately redundant, explaining the constraints from
  different perspectives. The contract between an EventStream and its
  subscriber is as follows:</p>

  <ol>
  <li>For each new value, the subscriber function is called. The new
  value is wrapped into a <code>Next</code> event.</li>
  <li>The subscriber function returns a result which is either <code>Bacon.noMore</code> or
  <code>Bacon.More</code>. The <code>undefined</code> value is handled like <code>Bacon.more</code>.</li>
  <li>In case of <code>Bacon.noMore</code> the source must never call the subscriber again.</li>
  <li>When the stream ends, the subscriber function will be called with
  and <code>End</code> event. The return value of the subscribe function is
  ignored in this case.</li>
  </ol>

  <p>A <code>Property</code> behaves similarly to an <code>EventStream</code> except that </p>

  <ol>
  <li>On a call to <code>subscribe</code>, it will deliver its current value 
  (if any) to the provided subscriber function wrapped into an <code>Initial</code>
  event.</li>
  <li>This means that if the Property has previously emitted the value <code>x</code>
  to its subscribers and that is the latest value emitted, it will deliver
  this value to the new subscriber.</li>
  <li>Property may or may not have a current value to start with. Depends
  on how the Property was created.</li>
  </ol>

  <h3><a name="for-rxjs-users">For RxJs Users</a></h3>

  <p>Bacon.js is quite similar to RxJs, so it should be pretty easy to pick up. The
  major difference is that in bacon, there are two distinct kinds of Observables:
  the EventStream and the Property. The former is for discrete events while the 
  latter is for observable properties that have the concept of "current value".</p>

  <p>Also, there are no "cold observables", which
  means also that all EventStreams and Properties are consistent among subscribers:
  when as event occurs, all subscribers will observe the same event. If you're
  experienced with RxJs, you've probably bumped into some wtf's related to cold
  observables and inconsistent output from streams constructed using scan and startWith.
  None of that will happen with bacon.js.</p>

  <p>Error handling is also a bit different: the Error event does not
  terminate a stream. So, a stream may contain multiple errors. To me,
  this makes more sense than always terminating the stream on error; this
  way the application developer has more direct control over error
  handling. You can always use <code>stream.endOnError()</code> to get a stream
  that ends on error!</p>

  <h2><a name="examples">Examples</a></h2>

  <p>See <a href="https://github.com/raimohanska/bacon.js/blob/master/examples/examples.html">Examples</a></p>

  <p>See <a href="https://github.com/raimohanska/bacon.js/blob/master/spec/BaconSpec.coffee">Specs</a></p>

  <p>See Worzone <a href="http://juhajasatu.com/worzone/">demo</a> and <a href="http://github.com/raimohanska/worzone">source</a></p>

  <h2><a name="build">Build</a></h2>

  <p>Build the coffeescript source into javascript:</p>

  <pre><code>cake build</code></pre>

  <p>Result javascript file will be generated in <code>lib</code> directory.</p>

  <h2><a name="test">Test</a></h2>

  <p>Run unit tests:</p>

  <pre><code>npm install&amp;&amp;npm test</code></pre>

  <h2><a name="dependencies">Dependencies</a></h2>

  <p>Runtime: jQuery or Zepto.js (optional; just for jQ/Zepto bindings)
  Build/test: node.js, npm, coffeescript</p>

  <h2><a name="compatibility-with-other-libraries">Compatibility with other libraries</a></h2>

  <p>Bacon.js doesn't mess with prototypes or the global object. Only exceptions below.</p>

  <ul>
  <li>It exports the Bacon object. In a browser, this is added to the window object.</li>
  <li>If jQuery is defined, it adds the asEventStream method to jQuery (similarly to Zepto)</li>
  </ul>

  <p>So, it should be pretty much compatible and a nice citizen. </p>

  <p>I'm not sure how it works in case some other lib adds stuff to, say, Array prototype, though. Maybe add test for this later?</p>

  <h2><a name="compatibility-with-browsers">Compatibility with browsers</a></h2>

  <p>Bacon.js is not browser dependent, because it is not a UI library. Hence there are not actual browser tests and no
  "official" list of supported browsers.</p>

  <p>I have used Bacon.js with Chrome, Firefox, Safari, IE 8+, iPhone, iPad.</p>

  <h2><a name="node-js">Node.js</a></h2>

  <p>Sure. Works. Try it out.</p>

  <pre><code>npm install baconjs</code></pre>

  <p>Then type <code>node</code> and try the following</p>

  <pre><code>Bacon = require("baconjs").bacon()
Bacon.sequentially(1000, ["B", "A", "C", "O", "N"]).log()</code></pre>

  <h2><a name="why-use-bacon">Why use Bacon?</a></h2>

  <p>Why not RxJs or something else?</p>

  <ul>
  <li>There is no "something else"</li>
  <li>I want my bacon to be open source</li>
  <li>I want good documentation for my bacon</li>
  <li>I think the Observable abstraction is not good enough. It leaves too much room for variations in
  behaviour (like hot/cold observables). I feel much more comfortable with EventStream and Property.</li>
  <li>Bacon needs automatic tests. They also serve as documentation.</li>
  <li>I don't like messing with the Array prototype</li>
  <li>Because.</li>
  </ul>

  <h2><a name="contribute">Contribute</a></h2>

  <p>Use <a href="https://github.com/raimohanska/bacon.js/issues">Issues</a> and <a href="https://github.com/raimohanska/bacon.js/pulls">Pull Requests</a> on GitHub.</p>
</div>
</body>
</html>